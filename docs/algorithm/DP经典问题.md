---
title: Dynamic Programming
date: 2023-04-20
sidebar: auto
categories:
  - Algorithm
tags:
  - DP
---
## DP经典算法
### 01背包问题
#### 题目
有$N$件物品和一个容量为$V$的背包。放入第$i$件物品耗费的费用是$C_i$，得到的
价值是$W_i$。求解将哪些物品装入背包可使价值总和最大。
#### 基本思路
这是最基础的背包问题，特点是：每种物品仅有一件，可以选择放或不放。
用子问题定义状态：即$F[i, v]$表示前$i$件物品恰放入一个容量为$v$的背包可以获得的最大价值。则其状态转移方程便是：
$$
	F[i, v] = max
                \left.
                    \begin{cases}
                        F[i − 1, v], F[i − 1, v − Ci] + Wi
                    \end{cases}
                \right\}
$$
详细解释：“将前$i$件物品放入容量为$v$的背包中”这个子问题，若只考虑第$i$件物品的策略（放或不放），那么就可以转化为一个只和前$i − 1$件物品相关
的问题。如果不放第$i$件物品，那么问题就转化为“前$i − 1$件物品放入容量为$v$的背包中”，价值为$F[i − 1, v]$；如果放第$i$件物品，那么问题就转化为“前$i − 1$件物品放
入剩下的容量为$v − Ci$的背包中”，此时能获得的最大价值就是$F[i − 1, v − Ci]$再加上
通过放入第$i$件物品获得的价值$W_i$。
#### 伪代码
```
F[0, 0..V ] ← 0
for i ← 1 to N
    for v ← Ci to V
        F[i, v] ← max{F[i − 1, v], F[i − 1, v − Ci] + Wi}
```
#### 优化空间复杂度
以上方法的时间和空间复杂度均为$O(V N)$，其中时间复杂度应该已经不能再优化
了，但空间复杂度却可以优化到$O(V)$。
先考虑上面讲的基本思路如何实现，肯定是有一个主循环$i ← 1 . . . N$，每次算出来二维数组$F[i, 0 . . . V ]$的所有值。那么，如果只用一个数组$F[0 . . . V ]$，能不能保证第$i$次循环结束后$F[v]$中表示的就是我们定义的状态$F[i, v]$呢？$F[i, v]$是由$F[i − 1, v]$和$F[i − 1, v − Ci]$两个子问题递推而来，能否保证在推$F[i, v]$时（也即在第$i$次主循环中
推$F[v]$时）能够取用$F[i − 1, v]$和$F[i − 1, v − Ci]$的值呢？
事实上，这要求在每次主循环中我们以$v ← V . . . 0$的递减顺序计算$F[v]$，这样才
能保证计算$F[v]$时$F[v − Ci]$保存的是状态$F[i − 1, v − Ci]$的值。
#### 伪代码
```
F[0..V ] ← 0
for i ← 1 to N
    for v ← V to Ci 
        F[v] ← max{F[v], F[v − Ci] + Wi}
```
### 完全背包问题
### 多重背包问题
### ⼆维费⽤背包问题
### 分组背包问题
### 有依赖的背包问题
### 泛化物品
### 泛化物品的和
